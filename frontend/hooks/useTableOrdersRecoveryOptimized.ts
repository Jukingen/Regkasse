// T√ºrk√ße A√ßƒ±klama: Optimize edilmi≈ü masa sipari≈üleri recovery hook'u - sonsuz d√∂ng√º sorunlarƒ±nƒ± √ß√∂zer
// useApiManager kullanarak duplicate API √ßaƒürƒ±larƒ±nƒ± √∂nler ve akƒ±llƒ± cache y√∂netimi saƒülar

import { useState, useCallback, useRef, useEffect } from 'react';
import { useApiManager } from './useApiManager';
import { useAuth } from '../contexts/AuthContext';
import { apiClient } from '../services/api/config';

// Table order recovery interfaces
export interface TableOrderRecoveryItem {
  productId: string;
  productName: string;
  quantity: number;
  price: number;
  total: number;
  notes?: string;
}

export interface TableOrderRecovery {
  tableNumber?: number;
  cartId: string;
  customerName?: string;
  itemCount: number;
  totalAmount: number;
  status: string;
  createdAt: string;
  lastUpdated: string;
  items: TableOrderRecoveryItem[];
}

export interface TableOrdersRecoveryData {
  success: boolean;
  message: string;
  userId: string;
  tableOrders: TableOrderRecovery[];
  totalActiveTables: number;
  retrievedAt: string;
}

interface RecoveryState {
  isLoading: boolean;
  error: string | null;
  recoveryData: TableOrdersRecoveryData | null;
  isRecoveryCompleted: boolean;
  isInitialized: boolean;
}

/**
 * F5 sonrasƒ± masa sipari≈ülerini geri y√ºkleme hook'u - Optimize edilmi≈ü versiyon
 * RKSV kurallarƒ±na uygun g√ºvenlik kontrol√º yapar
 * Yalnƒ±zca kullanƒ±cƒ±nƒ±n kendi masa sipari≈ülerini getirir
 * OPTIMIZATION: useApiManager ile duplicate call'larƒ± √∂nler
 */
export const useTableOrdersRecoveryOptimized = () => {
  const { user } = useAuth();
  const { apiCall, getCachedData, setCachedData } = useApiManager();
  
  const [recoveryState, setRecoveryState] = useState<RecoveryState>({
    isLoading: false,
    error: null,
    recoveryData: null,
    isRecoveryCompleted: false,
    isInitialized: false,
  });

  // Ref'ler ile s√ºrekli re-render'ƒ± √∂nle
  const recoveryStateRef = useRef(recoveryState);

  // State g√ºncelleme fonksiyonlarƒ± - batch update
  const updateRecoveryState = useCallback((updates: Partial<RecoveryState>) => {
    setRecoveryState(prev => {
      const newState = { ...prev, ...updates };
      recoveryStateRef.current = newState;
      return newState;
    });
  }, []);

  /**
   * Backend'den t√ºm aktif masa sipari≈ülerini getir
   * RKSV uyumlu - yalnƒ±zca kullanƒ±cƒ±nƒ±n kendi sipari≈üleri
   * OPTIMIZATION: useApiManager ile duplicate call'larƒ± √∂nler
   */
  const fetchTableOrdersRecovery = useCallback(async (): Promise<TableOrdersRecoveryData | null> => {
    if (!user) {
      console.warn('User not authenticated for table orders recovery');
      return null;
    }

    // OPTIMIZATION: Eƒüer zaten fetch edildiyse ve data varsa, tekrar fetch yapma
    if (recoveryStateRef.current.isInitialized && recoveryStateRef.current.recoveryData) {
      console.log('üîÑ Table orders already fetched, returning cached data');
      return recoveryStateRef.current.recoveryData;
    }

    // Cache kontrol√º
    const userCacheKey = `table-orders-recovery:${user.id}`;
    const cachedData = getCachedData<TableOrdersRecoveryData>(userCacheKey);
    if (cachedData) {
      console.log('‚úÖ Cache hit for table orders recovery');
      updateRecoveryState({
        isLoading: false,
        error: null,
        recoveryData: cachedData,
        isRecoveryCompleted: true,
        isInitialized: true,
      });
      return cachedData;
    }

    updateRecoveryState({ isLoading: true, error: null });

    try {
      console.log('üîÑ Fetching table orders for recovery...');
      
      // API √ßaƒürƒ±sƒ± - useApiManager ile
      const result = await apiCall(
        'fetch-table-orders-recovery',
        async () => {
          const response = await apiClient.get('/cart/table-orders-recovery');
          
          // Debouncing kontrol√º - null response handle et
          if (response === null) {
            console.log('‚ö†Ô∏è API response null (debouncing), throwing error for retry...');
            throw new Error('API response is null due to debouncing');
          }
          
          // Response format kontrol√º
          if (!response || typeof response !== 'object') {
            throw new Error(`Invalid response format: ${JSON.stringify(response)}`);
          }
          
          const recoveryData = response as TableOrdersRecoveryData;

          if (recoveryData.success) {
            return recoveryData;
          } else {
            throw new Error(recoveryData.message || 'Failed to retrieve table orders');
          }
        },
        {
          cacheKey: userCacheKey,
          cacheTTL: 5, // 5 dakika cache
          skipDuplicate: true,
          retryCount: 2,
        }
      );

      if (result) {
        console.log(`‚úÖ Recovery completed: ${result.totalActiveTables} active table orders found`);
        
        updateRecoveryState({
          isLoading: false,
          error: null,
          recoveryData: result,
          isRecoveryCompleted: true,
          isInitialized: true,
        });

        // Cache'e kaydet (user scoped)
        setCachedData(userCacheKey, result, 5);

        return result;
      }

      return null;
    } catch (error: any) {
      const errorMessage = error?.response?.data?.message ?? error.message ?? 'Unknown error during recovery';
      console.error('‚ùå Table orders recovery failed:', errorMessage);
      
      updateRecoveryState({
        isLoading: false,
        error: errorMessage,
        recoveryData: null,
        isRecoveryCompleted: false,
        isInitialized: false,
      });

      return null;
    }
  }, [user, apiCall, setCachedData, getCachedData, updateRecoveryState]);

  /**
   * Manuel refresh i√ßin - sadece gerektiƒüinde kullanƒ±lƒ±r
   */
  const refreshTableOrders = useCallback(async (): Promise<TableOrdersRecoveryData | null> => {
    if (!user) return null;
    
    console.log('üîÑ Manual refresh of table orders...');
    
    // Cache'i temizle (user scoped)
    const userCacheKey = `table-orders-recovery:${user.id}`;
    setCachedData(userCacheKey, null as unknown as TableOrdersRecoveryData, 0);
    
    // Reset initialization flag to force fresh fetch
    updateRecoveryState({ isInitialized: false });
    
    return await fetchTableOrdersRecovery();
  }, [user, fetchTableOrdersRecovery, setCachedData, updateRecoveryState]);

  /**
   * Belirli bir masa i√ßin sipari≈ü bilgilerini getir
   */
  const getOrderForTable = useCallback((tableNumber: number): TableOrderRecovery | null => {
    if (!recoveryStateRef.current.recoveryData) return null;
    
    return recoveryStateRef.current.recoveryData.tableOrders.find(
      order => order.tableNumber === tableNumber
    ) ?? null;
  }, []);

  /**
   * T√ºm aktif masa numaralarƒ±nƒ± getir
   */
  const getActiveTableNumbers = useCallback((): number[] => {
    if (!recoveryStateRef.current.recoveryData) return [];
    
    return recoveryStateRef.current.recoveryData.tableOrders
      .map(order => order.tableNumber)
      .filter((tableNumber): tableNumber is number => tableNumber !== undefined)
      .sort((a, b) => a - b);
  }, []);

  /**
   * Recovery durumunu sƒ±fƒ±rla
   */
  const resetRecovery = useCallback(() => {
    // Cache'i temizle (user scoped)
    if (user?.id) {
      const userCacheKey = `table-orders-recovery:${user.id}`;
      setCachedData(userCacheKey, null as unknown as TableOrdersRecoveryData, 0);
    }
    
    updateRecoveryState({
      isLoading: false,
      error: null,
      recoveryData: null,
      isRecoveryCompleted: false,
      isInitialized: false,
    });
  }, [setCachedData, user, updateRecoveryState]);

  /**
   * Sayfa y√ºklendiƒüinde otomatik recovery yapar
   * OPTIMIZATION: Sadece user deƒüi≈ütiƒüinde √ßalƒ±≈üƒ±r
   */
  useEffect(() => {
    let isMounted = true;

    const performRecovery = async () => {
      // Sadece user varsa ve hen√ºz initialize edilmemi≈üse √ßalƒ±≈ü
      if (!user || recoveryStateRef.current.isInitialized) {
        console.log('üîÑ Recovery skipped:', { 
          hasUser: !!user, 
          isInitialized: recoveryStateRef.current.isInitialized 
        });
        return;
      }

      console.log('üîÑ Starting table orders recovery from backend...');
      await fetchTableOrdersRecovery();
    };

    if (isMounted) {
      performRecovery();
    }

    return () => {
      isMounted = false;
    };
  }, [user, fetchTableOrdersRecovery]); // fetchTableOrdersRecovery dependency'si eklendi

  // Token g√ºncellenince recovery'yi tekrar dene (√∂rn. login/refresh sonrasƒ±)
  useEffect(() => {
    const handler = () => {
      if (user) {
        console.log('üîÑ auth-token-updated received, refreshing table orders');
        refreshTableOrders();
      }
    };
    if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {
      window.addEventListener('auth-token-updated', handler);
      return () => window.removeEventListener('auth-token-updated', handler);
    }
    return () => {};
  }, [user, refreshTableOrders]);

  return {
    // State
    isLoading: recoveryStateRef.current.isLoading,
    error: recoveryStateRef.current.error,
    recoveryData: recoveryStateRef.current.recoveryData,
    isRecoveryCompleted: recoveryStateRef.current.isRecoveryCompleted,
    isInitialized: recoveryStateRef.current.isInitialized,
    
    // Actions
    fetchTableOrdersRecovery,
    refreshTableOrders,
    getOrderForTable,
    getActiveTableNumbers,
    resetRecovery,
    
    // Helper properties
    hasActiveOrders: (recoveryStateRef.current.recoveryData?.totalActiveTables ?? 0) > 0,
    totalActiveTables: recoveryStateRef.current.recoveryData?.totalActiveTables ?? 0,
  };
};
