import AsyncStorage from '@react-native-async-storage/async-storage';
import { router, useRouter } from 'expo-router';
import { jwtDecode } from 'jwt-decode';
import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';

import i18n from '../i18n';
import * as authService from '../services/api/authService';
import { handleAPIError } from '../services/errorService';
import { getUserSettings, getDefaultUserSettings } from '../services/api/userSettingsService';
// CRITICAL FIX: useTranslation hook'unu kaldƒ±rdƒ±k - infinite loop'a neden oluyordu

// Cart cache temizleme i√ßin event listener
const CART_CLEAR_EVENT = 'logout-clear-cache';

interface User {
    id: string; // Required field
    username?: string;
    email: string;
    role: string;
    firstName?: string;
    lastName?: string;
    roles?: string[];
    token?: string; // Token field'ƒ± eklendi
}

interface AuthResponse {
    token: string;
    refreshToken: string;
    user: User;
}

interface AuthContextType {
    user: User | null;
    isAuthenticated: boolean;
    isLoading: boolean;
    login: (username: string, password: string) => Promise<void>;
    logout: () => Promise<void>;
    checkAuthStatus: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export { AuthContext };

export function AuthProvider({ children }: { children: React.ReactNode }) {
    const [user, setUser] = useState<User | null>(null);
    const [isAuthenticated, setIsAuthenticated] = useState(false);
    const [isLoading, setIsLoading] = useState(true);
    const [justLoggedIn, setJustLoggedIn] = useState(false);
    const [lastActivity, setLastActivity] = useState<number>(Date.now());
    const [inactivityTimer, setInactivityTimer] = useState<ReturnType<typeof setTimeout> | null>(null);
    
    // Inactivity timeout (30 dakika)
    const INACTIVITY_TIMEOUT = 30 * 60 * 1000; // 30 dakika

    // üßπ Cart cache temizleme fonksiyonu
    const clearCartCache = useCallback(async () => {
        try {
            console.log('üßπ Cart cache temizleniyor...');
            
            // AsyncStorage'dan cart verilerini temizle
            const cartKeys = [
                'currentCartId',
                'tableCarts',
                'cartData',
                'cartItems',
                'cartState'
            ];
            
            for (const key of cartKeys) {
                await AsyncStorage.removeItem(key);
            }
            
            // Local storage'dan cart verilerini temizle (web i√ßin)
            if (typeof window !== 'undefined') {
                const localStorageKeys = Object.keys(localStorage).filter(key => 
                    key.includes('cart') || key.includes('Cart') || key.includes('table')
                );
                
                localStorageKeys.forEach(key => {
                    localStorage.removeItem(key);
                    console.log(`üóëÔ∏è LocalStorage key removed: ${key}`);
                });
            }
            
            console.log('‚úÖ Cart cache temizlendi');
        } catch (error) {
            console.error('‚ùå Cart cache temizleme hatasƒ±:', error);
        }
    }, []);

    const checkTokenExpiration = (token: string): boolean => {
        try {
            const decoded = jwtDecode(token);
            const currentTime = Date.now() / 1000;
            return decoded.exp ? decoded.exp > currentTime : false;
        } catch (error) {
            console.error('Token expiration check failed:', error);
            return false;
        }
    };

    // Kullanƒ±cƒ± aktivitesini kaydet
    const updateActivity = useCallback(() => {
        setLastActivity(Date.now());
    }, []);

    // Inactivity timer'ƒ± ba≈ülat
    const startInactivityTimer = useCallback(() => {
        if (inactivityTimer) {
            clearTimeout(inactivityTimer);
        }

        const timer = setTimeout(() => {
            console.log('User inactive for 30 minutes, logging out...');
            // CRITICAL FIX: Circular dependency'yi √∂nlemek i√ßin logout'u direkt √ßaƒüƒ±rmƒ±yoruz
            // Bunun yerine state'i temizliyoruz
            setUser(null);
            setIsAuthenticated(false);
            setJustLoggedIn(false);
            // AsyncStorage temizliƒüi
            AsyncStorage.multiRemove(['token', 'refreshToken', 'user', 'tokenExpiry']);
        }, INACTIVITY_TIMEOUT);

        setInactivityTimer(timer);
    }, [inactivityTimer]); // logout dependency'sini kaldƒ±rdƒ±k

    // Inactivity timer'ƒ± durdur
    const stopInactivityTimer = useCallback(() => {
        if (inactivityTimer) {
            clearTimeout(inactivityTimer);
            setInactivityTimer(null);
        }
    }, [inactivityTimer]);

    // üßπ Logout event listener - Cart cache temizleme i√ßin
    useEffect(() => {
        const handleLogoutEvent = () => {
            console.log('üì° Logout event received, clearing cart cache...');
            clearCartCache();
        };

        // Event listener ekle - Platform-aware
        if (typeof window !== 'undefined' && window.addEventListener) {
            try {
                window.addEventListener(CART_CLEAR_EVENT, handleLogoutEvent);
                console.log('‚úÖ Web platform: cart clear event listener added');
                
                // Cleanup
                return () => {
                    if (typeof window !== 'undefined' && window.removeEventListener) {
                        window.removeEventListener(CART_CLEAR_EVENT, handleLogoutEvent);
                        console.log('‚úÖ Web platform: cart clear event listener removed');
                    }
                };
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to add window event listener:', error);
            }
        } else {
            console.log('üì± Mobile platform: window events not available, using direct method');
            // Mobile platformda direkt √ßaƒürƒ± kullanƒ±labilir (gerekirse)
        }
    }, [clearCartCache]);

    const checkAuthStatus = useCallback(async () => {
        const startTime = Date.now();
        console.log(`üîç [${new Date().toISOString()}] Auth status check ba≈ülatƒ±ldƒ±...`); // Debug log
        console.log(`üìä [${new Date().toISOString()}] Current state:`, { 
            justLoggedIn, 
            isAuthenticated, 
            hasUser: !!user,
            userId: user?.id 
        }); // Debug log
        
        try {
            // Eƒüer yeni login olduysa auth check'i atla
            if (justLoggedIn) {
                console.log(`üÜï [${new Date().toISOString()}] Yeni login, auth check atlanƒ±yor...`); // Debug log
                return;
            }

            // Eƒüer zaten authenticated deƒüilse ve user yoksa, auth check yapma
            if (!isAuthenticated && !user) {
                console.log(`üö´ [${new Date().toISOString()}] Zaten authenticated deƒüil, auth check atlanƒ±yor...`); // Debug log
                return;
            }

            console.log(`‚úÖ [${new Date().toISOString()}] Auth check ko≈üullarƒ± ge√ßildi, devam ediliyor...`); // Debug log

            // Timeout ekle - 10 saniye sonra otomatik √ßƒ±kƒ±≈ü
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => {
                    reject(new Error('Auth check timeout - 10 seconds exceeded'));
                }, 10000);
            });

            // Race condition ile timeout ekle
            await Promise.race([
                (async () => {
                    console.log(`üîç [${new Date().toISOString()}] AsyncStorage'dan token alƒ±nƒ±yor...`); // Debug log
                    
                    // Token'ƒ± AsyncStorage'dan al
                    const token = await AsyncStorage.getItem('token');
                    console.log(`üîë [${new Date().toISOString()}] Token check:`, { 
                        hasToken: !!token, 
                        tokenLength: token?.length,
                        tokenPreview: token ? `${token.substring(0, 20)}...` : 'none'
                    }); // Debug log

                    if (!token) {
                        console.log(`‚ùå [${new Date().toISOString()}] Token bulunamadƒ±, logout gerekli`); // Debug log
                        // Token yoksa oturumu sonlandƒ±r
                        setUser(null);
                        setIsAuthenticated(false);
                        await AsyncStorage.multiRemove(['token', 'refreshToken', 'user']);
                        console.log(`‚úÖ [${new Date().toISOString()}] Token yok, logout tamamlandƒ±`); // Debug log
                        return;
                    }

                    console.log(`‚úÖ [${new Date().toISOString()}] Token bulundu, temizleniyor...`); // Debug log

                    // Token'ƒ± temizle (Bearer prefix olmadan)
                    const cleanToken = token.startsWith('Bearer ') ? token.replace('Bearer ', '') : token;

                    console.log(`üîç [${new Date().toISOString()}] Token s√ºresi kontrol ediliyor...`); // Debug log

                    // Token s√ºresini kontrol et
                    const isTokenExpired = checkTokenExpiration(cleanToken);
                    console.log(`‚è∞ [${new Date().toISOString()}] Token expiration check:`, { 
                        isExpired: isTokenExpired,
                        cleanTokenLength: cleanToken.length 
                    }); // Debug log

                    if (isTokenExpired) {
                        console.log(`‚è∞ [${new Date().toISOString()}] Token s√ºresi dolmu≈ü, refresh deneniyor...`); // Debug log
                        
                        // Refresh token ile yenileme dene
                        const refreshToken = await AsyncStorage.getItem('refreshToken');
                        console.log(`üîÑ [${new Date().toISOString()}] Refresh token check:`, { 
                            hasRefreshToken: !!refreshToken,
                            refreshTokenLength: refreshToken?.length 
                        }); // Debug log
                        
                        if (refreshToken) {
                            try {
                                console.log(`üîÑ [${new Date().toISOString()}] Token refresh API √ßaƒürƒ±lƒ±yor...`); // Debug log
                                
                                // Token s√ºresi dolmu≈üsa refresh token ile yenile
                                const newToken = await authService.refreshToken();
                                console.log(`üÜï [${new Date().toISOString()}] Token refresh response:`, { 
                                    hasNewToken: !!newToken,
                                    newTokenLength: newToken?.length 
                                }); // Debug log

                                if (newToken) {
                                    console.log(`‚úÖ [${new Date().toISOString()}] Yeni token alƒ±ndƒ±, user bilgisi g√ºncelleniyor...`); // Debug log
                                    
                                    await AsyncStorage.setItem('token', newToken);
                                    // Kullanƒ±cƒ± bilgilerini g√ºncelle
                                    const userResponse = await authService.getCurrentUser();
                                    console.log(`üë§ [${new Date().toISOString()}] User info after refresh:`, { 
                                        hasUser: !!userResponse, 
                                        userId: userResponse?.id,
                                        userName: userResponse?.username 
                                    }); // Debug log
                                    
                                    if (userResponse && userResponse.id) {
                                        const userWithToken: User = {
                                            ...userResponse,
                                            token: newToken
                                        };
                                        setUser(userWithToken);
                                        setIsAuthenticated(true);
                                        await AsyncStorage.setItem('user', JSON.stringify(userWithToken));
                                        console.log(`‚úÖ [${new Date().toISOString()}] Token refresh ba≈üarƒ±lƒ±, user g√ºncellendi`); // Debug log
                                        return; // Ba≈üarƒ±lƒ± refresh sonrasƒ± √ßƒ±k
                                    } else {
                                        throw new Error('Invalid user response after refresh');
                                    }
                                } else {
                                    throw new Error('No new token received');
                                }
                            } catch (refreshError) {
                                console.error(`‚ùå [${new Date().toISOString()}] Token refresh failed:`, refreshError); // Debug log
                                // Refresh ba≈üarƒ±sƒ±z olursa oturumu sonlandƒ±r
                                console.log(`‚ùå [${new Date().toISOString()}] Token refresh ba≈üarƒ±sƒ±z, logout yapƒ±lƒ±yor...`); // Debug log
                                setUser(null);
                                setIsAuthenticated(false);
                                await AsyncStorage.multiRemove(['token', 'refreshToken', 'user']);
                                console.log(`‚úÖ [${new Date().toISOString()}] Refresh ba≈üarƒ±sƒ±z, logout tamamlandƒ±`); // Debug log
                                return;
                            }
                        } else {
                            console.log(`‚ùå [${new Date().toISOString()}] Refresh token bulunamadƒ±, logout yapƒ±lƒ±yor...`); // Debug log
                            // RefreshToken yoksa oturumu sonlandƒ±r
                            setUser(null);
                            setIsAuthenticated(false);
                            await AsyncStorage.multiRemove(['token', 'refreshToken', 'user']);
                            console.log(`‚úÖ [${new Date().toISOString()}] Refresh token yok, logout tamamlandƒ±`); // Debug log
                            return;
                        }
                    } else {
                        console.log(`‚úÖ [${new Date().toISOString()}] Token ge√ßerli, user bilgisi kontrol ediliyor...`); // Debug log
                        
                        // Token ge√ßerliyse kullanƒ±cƒ± bilgilerini kontrol et
                        try {
                            console.log(`üîÑ [${new Date().toISOString()}] User bilgisi API'den alƒ±nƒ±yor...`); // Debug log
                            
                            const userResponse = await authService.getCurrentUser();
                            console.log(`üë§ [${new Date().toISOString()}] User info check:`, { 
                                hasUser: !!userResponse, 
                                userId: userResponse?.id,
                                userName: userResponse?.username 
                            }); // Debug log
                            
                            // userResponse'da id field'ƒ±nƒ±n olduƒüunu kontrol et
                            if (!userResponse || !userResponse.id) {
                                throw new Error('Invalid user response - missing ID');
                            }
                            
                            // Mevcut user state ile kar≈üƒ±la≈ütƒ±r
                            if (user && user.id === userResponse.id) {
                                console.log(`‚úÖ [${new Date().toISOString()}] User bilgisi g√ºncel, deƒüi≈üiklik gerekmiyor`); // Debug log
                                return; // User zaten g√ºncel, deƒüi≈üiklik yapma
                            }
                            
                            console.log(`üîÑ [${new Date().toISOString()}] User bilgisi g√ºncelleniyor...`); // Debug log
                            
                            // Token'ƒ± temizle (Bearer prefix olmadan)
                            const userWithToken: User = {
                                ...userResponse,
                                token: cleanToken
                            };
                            
                            setUser(userWithToken);
                            setIsAuthenticated(true);
                            await AsyncStorage.setItem('user', JSON.stringify(userWithToken));
                            console.log(`‚úÖ [${new Date().toISOString()}] User bilgisi g√ºncellendi`); // Debug log
                        } catch (userError) {
                            console.error(`‚ùå [${new Date().toISOString()}] User info fetch failed:`, userError); // Debug log
                            // Kullanƒ±cƒ± bilgisi alƒ±namazsa oturumu sonlandƒ±r
                            console.log(`‚ùå [${new Date().toISOString()}] User bilgisi alƒ±namadƒ±, logout yapƒ±lƒ±yor...`); // Debug log
                            setUser(null);
                            setIsAuthenticated(false);
                            await AsyncStorage.multiRemove(['token', 'refreshToken', 'user']);
                            console.log(`‚úÖ [${new Date().toISOString()}] User bilgisi alƒ±namadƒ±, logout tamamlandƒ±`); // Debug log
                            return;
                        }
                    }
                })(),
                timeoutPromise
            ]);
        } catch (error) {
            console.error(`‚ùå [${new Date().toISOString()}] Auth status check failed:`, error); // Debug log
            // Hata durumunda oturumu sonlandƒ±r
            console.log(`‚ùå [${new Date().toISOString()}] Auth check hatasƒ±, logout yapƒ±lƒ±yor...`); // Debug log
            setUser(null);
            setIsAuthenticated(false);
            await AsyncStorage.multiRemove(['token', 'refreshToken', 'user']);
            console.log(`‚úÖ [${new Date().toISOString()}] Auth check hatasƒ±, logout tamamlandƒ±`); // Debug log
        } finally {
            const endTime = Date.now();
            const duration = endTime - startTime;
            console.log(`üîç [${new Date().toISOString()}] Auth status check tamamlandƒ± (${duration}ms)`); // Debug log
            
            // CRITICAL FIX: Auth check tamamlandƒ±ktan sonra loading state'i false yap
            setIsLoading(false);
            console.log(`‚úÖ [${new Date().toISOString()}] Loading state false yapƒ±ldƒ±`); // Debug log
        }
    }, [justLoggedIn]); // CRITICAL FIX: user ve isAuthenticated dependency'lerini kaldƒ±rdƒ±k - infinite loop'a neden oluyordu

    // CRITICAL FIX: checkAuthStatus'u sadece mount olduƒüunda bir kez √ßaƒüƒ±r
    useEffect(() => {
        console.log('AuthProvider mounted, checking initial auth status...'); // Debug log
        checkAuthStatus();
    }, []); // CRITICAL FIX: checkAuthStatus dependency'sini kaldƒ±rdƒ±k - sadece mount olduƒüunda bir kez √ßalƒ±≈üsƒ±n

    // CRITICAL FIX: Inactivity tracking'i optimize et
    useEffect(() => {
        if (isAuthenticated && user) {
            // Timer'ƒ± ba≈ülat
            startInactivityTimer();

            // Global event listener'larƒ± ekle
            const handleActivity = () => {
                updateActivity();
                startInactivityTimer(); // Timer'ƒ± yeniden ba≈ülat
            };

            // Touch, scroll, key press event'lerini dinle
            // Platform-aware event listeners - document only exists in web
            if (typeof document !== 'undefined') {
                document?.addEventListener?.('touchstart', handleActivity);
                document?.addEventListener?.('scroll', handleActivity);
                document?.addEventListener?.('keydown', handleActivity);
                document?.addEventListener?.('mousedown', handleActivity);
            }

            return () => {
                stopInactivityTimer();
                // Platform-aware cleanup - document only exists in web
                if (typeof document !== 'undefined') {
                    document?.removeEventListener?.('touchstart', handleActivity);
                    document?.removeEventListener?.('scroll', handleActivity);
                    document?.removeEventListener?.('keydown', handleActivity);
                    document?.removeEventListener?.('mousedown', handleActivity);
                }
            };
        } else {
            stopInactivityTimer();
        }
    }, [isAuthenticated, user, startInactivityTimer, stopInactivityTimer, updateActivity]);

    // CRITICAL FIX: Login sonrasƒ± navigation'ƒ± optimize et
    useEffect(() => {
        if (justLoggedIn && isAuthenticated && user) {
            console.log('Login successful, attempting navigation...'); // Debug log
            
            // Navigation'ƒ± dene
            const attemptNavigation = async () => {
                try {
                    if (router && typeof router.push === 'function') {
                        console.log('Navigating to cash-register...'); // Debug log
                        await router.push("/(tabs)/cash-register");
                        console.log('Navigation successful!'); // Debug log
                    } else {
                        console.error('Router not available for navigation'); // Debug log
                    }
                } catch (error) {
                    console.error('Navigation failed:', error); // Debug log
                }
            };
            
            // Kƒ±sa bir gecikme ile navigation'ƒ± dene
            setTimeout(attemptNavigation, 100);
            
            // 2 saniye sonra flag'i temizle
            const timer = setTimeout(() => {
                setJustLoggedIn(false);
            }, 2000);
            
            return () => clearTimeout(timer);
        }
    }, [justLoggedIn, isAuthenticated, user]);

    // Cart reset will be handled by the component that uses AuthContext

    const login = async (username: string, password: string) => {
        console.log('Login function called with username:', username); // Debug log
        try {
            setIsLoading(true);
            setJustLoggedIn(true); // Login ba≈üladƒ±ƒüƒ±nda flag'i set et
            console.log('Making login API request...'); // Debug log
            
            // Backend Email ve Password bekliyor
            const response = await authService.login({ email: username, password });
            console.log('Login API response:', response); // Debug log

            // API client response interceptor'ƒ± response.data d√∂nd√ºr√ºyor
            const { token, user: loggedInUser, refreshToken } = response;

            if (!token || !loggedInUser) {
                console.error('Invalid login response:', response); // Debug log
                throw new Error('Invalid login response');
            }

            console.log('Storing token and user data...'); // Debug log
            
            // Token'ƒ± Bearer prefix olmadan kaydet
            const cleanToken = token.startsWith('Bearer ') ? token.replace('Bearer ', '') : token;
            await AsyncStorage.setItem('token', cleanToken);
            console.log('Token stored without Bearer prefix:', cleanToken);
            
            await AsyncStorage.setItem('user', JSON.stringify(loggedInUser));
            
            // Eƒüer refreshToken varsa onu da kaydet
            if (refreshToken) {
                await AsyncStorage.setItem('refreshToken', refreshToken);
                console.log('Refresh token stored:', !!refreshToken);
            }

            // --- CART TEMƒ∞ZLƒ∞ƒûƒ∞ ---
            console.log('üßπ Login sonrasƒ± cart cache temizleniyor...');
            await AsyncStorage.removeItem('currentCartId');
            
            // Cart cache temizleme event'ini tetikle - Platform-aware
            if (typeof window !== 'undefined' && window.dispatchEvent) {
                try {
                    const clearCartEvent = new CustomEvent(CART_CLEAR_EVENT);
                    window.dispatchEvent(clearCartEvent);
                    console.log('‚úÖ Web platform: Cart clear event dispatched');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Failed to dispatch cart clear event:', error);
                }
            } else {
                console.log('üì± Mobile platform: Direct cart clear called');
                // Mobile platformda direkt clearCartCache √ßaƒüƒ±r
                clearCartCache();
            }
            
            // Local storage'dan cart verilerini temizle
            const cartKeys = [
                'currentCartId',
                'tableCarts',
                'cartData',
                'cartItems',
                'cartState'
            ];
            
            for (const key of cartKeys) {
                await AsyncStorage.removeItem(key);
            }
            
            console.log('‚úÖ Cart cache temizlendi');
            // --- CART TEMƒ∞ZLƒ∞ƒûƒ∞ SONU ---

            console.log('Setting user state...'); // Debug log
            console.log('User data to set:', loggedInUser); // Debug log
            
            // State'leri birlikte set et - √∂nce user, sonra authentication
            const userWithToken = {
                ...loggedInUser,
                token: cleanToken // cleanToken'ƒ± user state'ine ekle (Bearer prefix olmadan)
            };
            setUser(userWithToken);
            console.log('User state set to:', userWithToken); // Debug log
            
            // Kƒ±sa bir gecikme ile authentication state'ini set et
            setTimeout(() => {
                setIsAuthenticated(true);
                console.log('Authentication state set to true'); // Debug log
            }, 100);
            
            // Kullanƒ±cƒ± ayarlarƒ±nƒ± backend'den √ßek
            try {
                console.log('Fetching user settings after login...');
                
                // Token'ƒ±n doƒüru ≈üekilde kaydedildiƒüini kontrol et
                const savedToken = await AsyncStorage.getItem('token');
                console.log('Saved token before user settings request:', !!savedToken, 'length:', savedToken?.length);
                
                const userSettings = await getUserSettings();
                console.log('User settings fetched successfully:', userSettings);
                
                if (userSettings?.language) {
                    // CRITICAL FIX: Dil deƒüi≈ütirme i≈ülemini optimize et
                    const currentLang = i18n.language;
                    if (currentLang !== userSettings.language) {
                        await i18n.changeLanguage(userSettings.language);
                        console.log('Language changed to:', userSettings.language);
                    }
                } else {
                    // Varsayƒ±lan dil olarak de-DE kullan (Avusturya Almancasƒ±)
                    const currentLang = i18n.language;
                    if (currentLang !== 'de-DE') {
                        await i18n.changeLanguage('de-DE');
                        console.log('Default language set: de-DE');
                    }
                }
            } catch (err) {
                console.warn('Kullanƒ±cƒ± ayarlarƒ± backendden alƒ±namadƒ±, varsayƒ±lan dil kullanƒ±lƒ±yor:', err);
                // Varsayƒ±lan dil olarak de-DE kullan
                const currentLang = i18n.language;
                if (currentLang !== 'de-DE') {
                    await i18n.changeLanguage('de-DE');
                }
            }

            // State g√ºncellemesinin tamamlanmasƒ±nƒ± bekle
            await new Promise(resolve => setTimeout(resolve, 100));

            // State'lerin doƒüru set edildiƒüini kontrol et
            console.log('State set, checking...'); // Debug log
            console.log('Current state values:', { isAuthenticated, user }); // Debug log
            console.log('Login process completed, navigation will be handled by useEffect'); // Debug log
        } catch (error) {
            console.error('Login failed:', error); // Debug log
            setJustLoggedIn(false); // Hata durumunda flag'i temizle
            const apiError = handleAPIError(error);
            throw new Error(apiError.message);
        } finally {
            setIsLoading(false);
        }
    };

    const logout = useCallback(async () => {
        console.log('Logout function called'); // Debug log
        
        try {
            // üßπ √ñNCE CART CACHE'ƒ∞ TEMƒ∞ZLE
            await clearCartCache();
            
            // Backend logout API √ßaƒürƒ±sƒ± yap
            const token = await AsyncStorage.getItem('token');
            if (token) {
                try {
                    await authService.logout();
                    console.log('Logout API request successful'); // Debug log
                    
                    // üßπ BACKEND LOGOUT API - Kullanƒ±cƒ± sepetlerini temizle
                    try {
                        console.log('üßπ Backend logout API √ßaƒürƒ±lƒ±yor...');
                        
                        // Token'ƒ± temizle (Bearer prefix olmadan)
                        const cleanToken = token.replace('Bearer ', '');
                        
                        const logoutResponse = await fetch('http://localhost:5183/api/auth/logout', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${cleanToken}`,
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        if (logoutResponse.ok) {
                            const result = await logoutResponse.json();
                            console.log('‚úÖ Backend logout ba≈üarƒ±lƒ±:', result.message);
                        } else {
                            // Backend'den hata mesajƒ±nƒ± al
                            let errorMessage = 'Backend logout failed';
                            try {
                                const errorData = await logoutResponse.json();
                                errorMessage = errorData.message || errorMessage;
                            } catch {
                                errorMessage = `Backend logout failed: ${logoutResponse.status} ${logoutResponse.statusText}`;
                            }
                            console.warn('‚ö†Ô∏è Backend logout warning:', errorMessage);
                        }
                    } catch (backendError) {
                        console.warn('‚ö†Ô∏è Backend logout API hatasƒ± (non-critical):', backendError);
                    }
                } catch (apiError) {
                    console.warn('‚ö†Ô∏è Auth service logout hatasƒ± (non-critical):', apiError);
                }
            }
            
            // üßπ LOCAL STATE VE STORAGE TEMƒ∞ZLƒ∞ƒûƒ∞
            console.log('üßπ Local state ve storage temizleniyor...');
            
            // State'leri temizle
            setUser(null);
            setIsAuthenticated(false);
            setJustLoggedIn(false);
            
            // AsyncStorage'dan t√ºm auth verilerini temizle
            await AsyncStorage.multiRemove([
                'token',
                'refreshToken',
                'user',
                'tokenExpiry'
            ]);
            
            // Local storage'dan auth verilerini temizle (web i√ßin)
            if (typeof window !== 'undefined' && window.localStorage) {
                const authKeys = Object.keys(localStorage).filter(key => 
                    key.includes('token') || key.includes('user') || key.includes('auth')
                );
                authKeys.forEach(key => {
                    localStorage.removeItem(key);
                    console.log(`üóëÔ∏è LocalStorage auth key removed: ${key}`);
                });
            }
            
            console.log('‚úÖ Local state ve storage temizlendi');
            
            // üßπ CART CACHE TEMƒ∞ZLƒ∞ƒûƒ∞ - Event ile
            if (typeof window !== 'undefined' && window.dispatchEvent) {
                try {
                    const clearCartEvent = new CustomEvent(CART_CLEAR_EVENT);
                    window.dispatchEvent(clearCartEvent);
                    console.log('‚úÖ Web platform: Cart clear event dispatched during logout');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Failed to dispatch cart clear event during logout:', error);
                }
            }
            
            // üßπ INACTIVITY TIMER TEMƒ∞ZLƒ∞ƒûƒ∞
            stopInactivityTimer();
            
            console.log('‚úÖ Logout completed successfully');
            
            // Login sayfasƒ±na y√∂nlendir
            if (router && typeof router.push === 'function') {
                try {
                    await router.push("/(auth)/login");
                    console.log('‚úÖ Navigation to login page successful');
                } catch (navigationError) {
                    console.error('‚ùå Navigation to login page failed:', navigationError);
                    // Fallback: window.location kullan (web i√ßin)
                    if (typeof window !== 'undefined') {
                        window.location.href = '/(auth)/login';
                    }
                }
            } else {
                console.warn('‚ö†Ô∏è Router not available for logout navigation');
                // Fallback: window.location kullan (web i√ßin)
                if (typeof window !== 'undefined') {
                    window.location.href = '/(auth)/login';
                }
            }
        } catch (error) {
            console.error('‚ùå Logout error:', error);
            // Hata durumunda bile state'i temizle
            setUser(null);
            setIsAuthenticated(false);
            setJustLoggedIn(false);
            
            // Login sayfasƒ±na y√∂nlendir
            if (router && typeof router.push === 'function') {
                try {
                    await router.push("/(auth)/login");
                } catch (navigationError) {
                    console.error('Navigation failed after logout error:', navigationError);
                }
            }
        }
    }, [clearCartCache, stopInactivityTimer, router]); // CRITICAL FIX: Dependency array'i optimize ettik

    return (
        <AuthContext.Provider value={{
            user,
            isAuthenticated,
            isLoading,
            login,
            logout,
            checkAuthStatus
        }}>
            {children}
        </AuthContext.Provider>
    );
}

export function useAuth() {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
} 